# 防抖和节流  

## 防抖  
每次事件触发则删除原来的定时器，建立新的定时器  
无论事件触发多少次，我都只执行最后一次的操作  
- 举例：提供一个按钮供你查询你未来对象的样子，无论你点击查询多少次，都只会在你最后一次点击之后查询  
- 举例：王者荣耀的回城功能，反复触发回城，只会确认最后一次，从最后一次触发开始计时  
- 场景：提交按钮、搜索词联想  
- 将几次操作合并为一此操作进行。原理是维护一个计时器，规定在 delay 时间后触发函数，但是在 delay 时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发  

## 节流  
如果在规定的时间间隔内二次触发事件，不理睬二次触发的操作，必须等当前的定时器完成之后再去执行下一个  
规定的事件内只会执行一次操作，如果触发多次，只有一次生效  
- 举例：公交车十分钟一趟，十分钟内有多人在车站我不管，十分钟一到就直接发车走人  
- 举例：游戏里面的技能冷却，放了技能，进入冷却，期间就算不停地点技能，也放不了，只能等冷却好，才可以再放  
- 场景：拖拽、resize、动画、滚动事件  
- 使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数  

## 防抖和节流的区别  
- 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数  
- 函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现  
