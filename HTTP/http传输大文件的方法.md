# HTTP 传输大文件的方法  
## 数据压缩 => 把大象变成小猪佩奇，再放进冰箱  
1. 浏览器在请求的时候通常会带上 `Accept-Encoding` 头字段，告诉服务端浏览器支持的压缩格式列表  
2. 服务器收到后可以从中选择一种压缩算法放进 `Content-Encoding` 响应头字段中，并把数据按照相应的算法进行压缩后再发送给浏览器  

- 缺点  
  gzip 等压缩算法通常只对文本文件有较好的压缩率，而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理也不会变小（甚至还有可能会增大一点），所以它就失效了  

> 不过数据压缩在处理文本的时候效果还是很好的，所以各大网站的服务器都会使用这个手段作为“保底”，例如，在 Nginx 里就会使用“gzip on”指令，启用对“text/html”的压缩  

## 分块传输  
- 如果大文件整体不能变小，那就把它拆开分解成多个小块，分批发送给浏览器，浏览器收到后在进行组装复原  
- 这样浏览器和服务器都不需要在内存中保存文件的全部内容，每次只需要收发一小部分，网络也不会被长时间占用，内存和带宽资源也可以节省  
- 在 HTTP 协议中就是 chunked 分块传输编码，在响应报文中使用 `Transfer-Encoding: chunked` 表示  
- 举例来说，就像是用魔法把大象变成乐高积木，拆散了之后装进冰箱，到达目的地之后再施法拼起来满血复活  

- 分块传输也可以用于“流式数据”，例如由数据库动态生成的表单页面，这种情况下 body 的数据长度是未知的，无法在头字段 `Content-Length` 中给一个确切的长度，所以也只能使用分块传输  

- `Transfer-Encoding: chunked` 和 `Content-Length` 这两个字段是互斥的，响应头中这两个字段是不能同时出现的，一个响应报文的传输要么是长度已知，要么是长度未知(chunked)  

### 分块传输的编码规则  
1. 每个分块包含两个部分，长度头和数据块
2. 长度头是以 CRLF（回车换行，即\r\n）结尾的一行明文，用 16 进制数字表示长度
3. 数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF
4. 最后用一个长度为 0 的块表示结束，即“0\r\n\r\n”

## 范围请求  
允许客户端在请求头里使用专门字段来表示只获取文件的一部分，相当于是客户端的化整为零  
- 范围请求不是服务器必须有的功能，可以实现也可以不实现，所以服务器必须在响应头中使用 `Accept-Ranges: bytes` 字段告诉客户端自己支持范围请求  
- 请求头 `Range` 是范围请求的专用字段，格式是 `bytes=x-y`，其中的 x 和 y 是以字节为单位的数据范围  
- x、y 表示的是“偏移量”，范围必须从 0 计数，例如前 10 个字节表示为“0-9”，第二个 10 字节表示为“10-19”，而“0-10”实际上是前 11 个字节  

- 服务器收到 `Range` 字段后进行处理需要做四件事：  
  1. 检查范围是否合法，**如果范围越界，返回状态码 416，表示范围请求有误，我无法处理**  
  2. 如果范围正确，服务器根据 `Range` 字段计算偏移量并读取文件片段，返回状态码 206 Partial Content  
  3. 服务器要添加给响应头添加一个 `Content-Range` 字段，告诉客户端片段的实际偏移量和资源的总大小，格式是`bytes x-y/length`

- 应用场景  
  - 看视频拖拽进度，根据时间点计算出文件的 Range，不用下载整个文件，精确的获取片段所在数据内容  
  - 常用下载工具中的多段下载、断点续传  
    1. 先发送一个 HEAD 请求，看服务器是否支持范围请求，同时获取文件的大小  
    2. 开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据  
    3. 下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了  

## 多段数据  
- 范围请求还支持在 `Range` 字段中使用多个 `x-y`，一次性获取多个片段  
- 需要使用一种特殊的 MIME 类型：`multipart/byteranges`，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数 `boundary=xxx` 给出段之间的分隔标记  
- 需要用分隔标记 boundry 来区分不同的片段  
  - 每一个分段必须以 `--boundry` 开始，之后要用 `Content-Type` 和 `Content-Range` 标记这段数据的类型和所在范围  
  - 以回车换行结束  
  - 最后用一个 `--boundary--` 表示所有的分段结束  

- 举例  
  ```bash
  HTTP/1.1 206 Partial Content
  Content-Type: multipart/byteranges; boundary=00000010101
  Content-Length: 189
  Connection: keep-alive
  Accept-Ranges: bytes


  --00000010101
  Content-Type: text/plain
  Content-Range: bytes 0-9/96

  i am xxxxx
  --00000010101
  Content-Type: text/plain
  Content-Range: bytes 20-29/96

  eex jspy e
  --00000010101--
  ```
