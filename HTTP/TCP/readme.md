# TCP 协议  
掘金文章学习建议 👉 https://juejin.im/post/5e527c58e51d4526c654bf41  

## OSI 七层模型 --- 开放式系统互联参考模型  
自顶向下分别为：  
应用层 -> 表示层 -> 会话层 -> 传输层 -> 网络层 -> 数据链路层 -> 物理层  

   应用层(HTTP)  
   表示层(解码和编码等)  
   会话层(session)  
   传输层(TCP/UDP)  
   网络层(IP)  
   数据链路层(MAC地址)  
   物理层  

## TCP 与 UDP 的区别？   
1. 都是位于传输层的协议(两种协议)  
    为什么同一层有两种协议？ -> 应用的场景、传输的内容不一样  
    Web: TCP(传输层)/IP(网络层)  

    客户端 Client 浏览器 index.html  
    服务器 Server  
    HTTP 协议 domain -> 服务器 ip 建立连接 req -> res Client  
    文件过大的话不可能直接传输，需要变成字节流  
    TCP 建立连接 可信 可控制 -> index.html 分割的字节流排序，而且不能少传  
2. 概念：  
  + TCP 是一个面向连接的(服务端和客户端)、可靠的(有状态，可控制)、基于字节流的传输层协议  
    **有状态**：TCP 会精确记录哪些数据发了、哪些数据被对方接受了、哪些没有被收到，并且保证数据包(字节流)按序到达，不允许半点差错  
    **可控制**：当意识到丢包或者网络环境不佳，TCP 会根据情况调整行为，控制发送速度或者重传  
  + UDP 面向无连接的传输层协议，无状态、不可控。常用于网络直播，电影，以传输速度为主要的要求，数据的到达完整性要求不高  
  | |  
  \\/  
  TCP -> 诸葛亮 || UDP -> 老子  

## TCP 三次握手  
TCP 协议是一个面向连接的可靠的协议，客户端和服务端双方必须确认对象具有接受和发送的能力  
1. 第一次：客户端向服务器端发送请求，服务端收到，**服务端确认客户端具有发送的能力**  
2. 第二次：服务端响应客户端请求，回复客户端，客户端收到，**客户端确认服务端具有接受和发送的能力**  
3. 第三次：客户端收到服务端响应之后，再给服务端回复收到，**服务端确认客户端具有接受的能力**  

## 为什么不是两次？  
根本原因：无法确认客户端的接受能力  

1. 如客户端发出连接请求，但因网络原因，连接请求延迟没有到达，于是 TCP以为发生丢包，客户端再重传一次连接请求。后来收到了确认，建立了连接  
2. 数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端已经断开了，忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源  

## 为什么不是四次？  
理论上来说四次握手也可以，但是三次握手已经建立了可靠的连接，没有必要再增加次数浪费资源  

## 什么是半连接队列？  
- 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列  

- 还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象  

- 服务器发送完 SYN-ACK 包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除  

## ISN(Initial Sequence Number)是固定的吗？  
- 当一端为建立连接而发送它的 SYN 时，它为连接选择一个初始序号。ISN 随时间而变化，因此每个连接都将具有不同的 ISN。ISN 可以看作是一个 32 比特的计数器，每 4ms 加 1。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释  

- 三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的  

## 三次握手过程中可以携带数据吗？  
- 第三次握手的时候可以携带，前两次握手不能携带数据  
- 原因：  
  + 假如第一次握手可以携带数据的话，如果有人要**恶意攻击服务器**，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。  
  + 也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态，对于客户端来说，已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，这个时候相对比较安全，可以携带数据  