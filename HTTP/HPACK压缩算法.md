# HPACK 压缩算法  
HTTP2.0 中使用 HPACK 压缩算法对请求头进行头部压缩，减少冗余报头  

## HPACK 的实现  
### 基本原理  
**HPACK 使用2个索引表(静态索引表和动态索引表)来把头部映射到索引值，并对不存在的头部使用 huffman 编码，并动态缓存到索引，从而达到压缩头部的效果**  

HPACK 中有2个索引表，分别是静态索引表和动态索引表  

### 静态索引表  
- 静态索引表是预定义在 RFC 中的固定头部，每一个头部会对应一个 Index  
- 当要发送的值符合静态索引表，也就是在静态索引表中的时候，直接使用相应的 Index 进行替代，这样就可以较大程度的压缩头部的大小  

> 静态索引表是预先定义好的，只有固定的几十个值，如果遇到不在静态索引表中的值时，就需要用到动态索引表  

### 动态索引表  
- 动态索引表是一个由先进先出队列维护的空间有限的表，里面维护的同样是头部与对应的索引  
- 每个动态表只针对一个连接，每个连接的压缩解压缩的上下文有且仅有一个动态表  
  HTTP/2 中引入了多路复用的概念，对于同一个域名的多个请求，会复用同一个连接  
- 当一个头部没有出现过的时候，会把它插入动态表中，下次同名的值就**可能**会在表中查到到索引并替换掉头部  
  动态索引表的空间是有限的，所以只是可能查找到并替换  

> 动态表的大小 = (每个 Header 的字节数的和+32) * 键值对个数  
> 1. 条目的大小是使用它的名字和值的长度计算的，没有任何霍夫曼编码应用  
> 2. 长度以八位字节为单位  
> 3. 额外的32个八位字节是与入口相关的估计开销  

- 32是为了头所占用的额外空间和计算头被引用次数而估计的值  
  动态表的最大字节数由 HTTP/2 的 SETTING 帧中的 SETTINGS_HEADER_TABLE_SIZE 来控制  

- 动态表最初是空的。在每个头部块被解压缩时添加条目。动态表可以包含重复的条目（即具有相同名称和相同值的条目）因此，重复条目不能被解码器视为错误  

- 压缩时，可以插入一个字节来动态的修改动态表的大小，但是不可以超过上面预设的值  

### 索引地址空间  
静态表和动态表合并成一个索引地址空间  
索引空间就是动态表和静态表组成的头部与索引的映射关系  
- 大于静态表长度的索引是指动态表中的元素  
  举例：加入静态表的大小固定的 61，则静态表就是从 1 到 61 的索引，然后动态表从新到旧，依次从 62 开始递增，这样就共同的组成了一个索引空间，且互不冲突  
  如果以后静态表扩充了，依次往后推即可  

- 
